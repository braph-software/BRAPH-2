\documentclass{tufte-handout}
\usepackage{braph2_devdoc}
%\geometry{showframe} % display margins for debugging page layout

\title{Implement a new Measure}

\author[The BRAPH~2 Developers]{The BRAPH~2 Developers}

\begin{document}

\maketitle

\begin{abstract}
\noindent
This is the developer tutorial for implementing a new measure. 
In this Tutorial, we will explain how to create the generator file \fn{*.gen.m} for a new measure which can the be compiled by \code{braph2genesis}, using the measures \code{Degree}, \code{DegreeAv}, and \code{Distance} as examples.
\end{abstract}

\tableofcontents

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of Degree}

We will start by implementing in detail the measure \code{Degree}, which applies to most graphs and is a direct extension of the element \code{Measure}.

\begin{lstlisting}[
	label=cd:m:degree:header,
	caption={
		{\bf Degree element header.}
		The \code{header} section of generator code for \fn{\_Degree.gen.m} provides the general information about the \code{Degree} element.
	}
]
%% ¡header!
Degree < Measure (m, degree) is the graph degree. ¥\circled{1}\circlednote{1}{The element \code{Degree} is defined as a subclass of \code{Measure}. The moniker will be \code{m}.}¥

%%% ¡description!
The degree of a node is the number of edges connected to the node within a layer. 
Connection weights are ignored in calculations.
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:degree:prop_update,
	caption={
		{\bf Degree element prop update.}
		The \code{props\_update} section of generator code for \fn{\_Degree.gen.m} updates the properties of the \code{Measure} element. This defines the core properties of the measure.
	}
]
%% ¡props_update!

%%% ¡prop!
NAME (constant, string) is the name of the degree.
%%%% ¡default!
'Degree'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the degree.
%%%% ¡default!
'The degree of a node is the number of edges connected to the node within a layer. Connection weights are ignored in calculations.'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the degree.

%%% ¡prop!
ID (data, string) is a few-letter code of the degree.
%%%% ¡default!
'Degree ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of the degree.
%%%% ¡default!
'Degree label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the degree.
%%%% ¡default!
'Degree notes'

%%% ¡prop! ¥\circled{1}\circlednote{1}{Measures have a \emph{shape}: \code{Measure.GLOBAL} (a value for the whole brain graph, e.g., average degree), \code{Measure.NODAL} (a value for each brain region, e.g., degree, or \code{Measure.BINODAL} (a value for each couple of brain regions, e.g., distance between couples of nodes).}¥
SHAPE (constant, scalar) is the measure shape __Measure.NODAL__.
%%%% ¡default!
Measure.NODAL

%%% ¡prop! ¥\circled{2}\circlednote{2}{Measures have a \emph{scope}: \code{Measure.SUPERGLOBAL} (a result for the whole multi-layer graph, e.g., overlapping strength), \code{Measure.UNILAYER} (a result for each layer, e.g., average strength), or \code{Measure.BILAYER} (a result for each couple of layers).}¥
SCOPE (constant, scalar) is the measure scope __Measure.UNILAYER__.
%%%% ¡default!
Measure.UNILAYER

%%% ¡prop! ¥\circled{3}\circlednote{3}{Measures are either \code{Measure.NONPARAMETRIC} (the usual case) or \code{Measure.PARAMETRIC} (depending on some parameter).}¥
PARAMETRICITY (constant, scalar) is the parametricity of the measure __Measure.NONPARAMETRIC__.
%%%% ¡default!
Measure.NONPARAMETRIC

%%% ¡prop! ¥\circled{4}\circlednote{4}{Each measure has a list of compatible graphs for which the measure can be used.}¥
COMPATIBLE_GRAPHS (constant, classlist) is the list of compatible graphs.
%%%% ¡default!
{'GraphWU' 'GraphBU' 'MultigraphBUD' 'MultigraphBUT' 'MultiplexWU' 'MultiplexBU' 'MultiplexBUD' 'MultiplexBUT' 'OrdMxWU' 'OrdMxBU'}

%%% ¡prop! ¥\circled{5}\circlednote{5}{The property \code{M} contains the code to be executed to calculate the measure. Here is where most of the action happens.}¥
M (result, cell) is the degree.
%%%% ¡calculate!
g = m.get('G'); ¥\circled{6}\circlednote{6}{retrieves the graph from the property \code{G} of the measure \code{m}.}¥
A = g.get('A'); ¥\circled{7}\circlednote{7}{retrieves the cell with the adjacency matrix (for graph) or 2D-cell array (for multigraph, multiplex, etc.).}¥

degree = cell(g.get('LAYERNUMBER'), 1); ¥\circled{8}\circlednote{8}{preallocates the variable to contain the result of the measure calculation.}¥

parfor li = 1:1:g.get('LAYERNUMBER')
    Aii = A{li, li};
    Aii = binarize(Aii); ¥\circled{9}\circlednote{9}{binarizes the adjacency matrix (removing diagonal).}¥
    degree(li) = {sum(Aii, 2)}; ¥\circled{10}\circlednote{10}{calculates the degree of the node for layer \code{li}.}¥
end

value = degree; ¥\circled{11}\circlednote{11}{returns the calcualted value of the measure \code{degree} assigning it to the output variable \code{value}.}¥
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:degree:tests,
	caption={
		{\bf Degree element tests.}
		The \code{tests} section from the element generator \fn{\_Degree.gen.m}.
		A test should be prepared for each graph with which the measure is compatible. The test should at least verify in some simple cases that the value of the measure is correct 
	}
]
%% ¡tests!

%%% ¡excluded_props! ¥\circled{1}\circlednote{1}{List of properties that are excluded from testing.}¥
[Degree.TEMPLATE Degree.PFM] 

%%% ¡test! ¥\circled{2}\circlednote{2}{Test for \code{GraphWU}. Similar tests should be implemented for each graph compatible with the measure.}¥
%%%% ¡name!
GraphWU
%%%% ¡probability! ¥\circled{3}\circlednote{3}{assings a low test execution probability.}¥
.01
%%%% ¡code!
B = [
    0   .6  1
    .6  0   0
    1   0   0
    ];

known_degree = {[2 1 1]'}; ¥\circled{4}\circlednote{4}{is the expected value of the measure calculated by external means.}¥

g = GraphWU('B', B); ¥\circled{5}\circlednote{5}{creates the graph.}¥

m_outside_g = Degree('G', g); ¥\circled{6}\circlednote{6}{creates the measure.}¥
assert(isequal(m_outside_g.get('M'), known_degree), ... ¥\circled{7}\circlednote{7}{tests that the value of the measure coicides with its expected value.}¥ 
    [BRAPH2.STR ':Degree:' BRAPH2.FAIL_TEST], ...
    [class(m_outside_g) ' is not being calculated correctly for ' class(g) '.'])

m_inside_g = g.get('MEASURE', 'Degree'); ¥\circled{8}\circlednote{8}{extracts the measure from the graph.}¥
assert(isequal(m_inside_g.get('M'), known_degree), ... ¥\circled{8}\circlednote{8}{tests that the value of the measure extracted from the graph coicides with its expected value.}¥
    [BRAPH2.STR ':Degree:' BRAPH2.FAIL_TEST], ...
    [class(m_inside_g) ' is not being calculated correctly for ' class(g) '.'])

¤...¤
\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of DegreeAv}

We can now use \code{Degree} as the basis to implement the global measure \code{DegreeAv}.
The parts of the code that are modified are highlighted.

\begin{lstlisting}[
	label=cd:m:degreeav:header,
	caption={
		{\bf DegreeAv element header.}
		The \code{header} section of generator code for \fn{\_DegreeAv.gen.m} provides the general information about the \code{DegreeAv} element.
		\expand{cd:m:degree:header}
	}
]
¤%% ¡header!¤
DegreeAv ¤<¤ Degree ¤(m, ¤average degree¤)¤ is the graph average degree. ¥\circled{1}\circlednote{1}{\code{DegreeAv} is a child of \code{Degree}.}¥

¤%%% ¡description!¤
The average degree of a graph is the average of all number of edges connected to a node within a layer. 
Connection weights are ignored in calculations.
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:degreeav:prop_update,
	caption={
		{\bf DegreeAv element prop update.}
		The \code{props\_update} section of generator code for \fn{\_DegreeAv.gen.m} updates the properties of the \code{Degree} element.
		\expand{cd:m:degree:prop_update}
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of the ¤average degree¤.
%%%% ¡default!¤
'DegreeAv'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of the ¤average degree¤.
%%%% ¡default!¤
'The average degree of a graph is the average of all number of edges connected to a node within a layer. Connection weights are ignored in calculations.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of the ¤average degree¤.¤

¤%%% ¡prop!
ID (data, string) is a few-letter code of the ¤average degree¤.
%%%% ¡default!¤
'DegreeAv ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of the ¤average degree¤.
%%%% ¡default!¤
'DegreeAv label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about the ¤average degree¤.
%%%% ¡default!¤
'DegreeAv notes'

¤%%% ¡prop!
SHAPE (constant, scalar) is the measure shape ¤__Measure.GLOBAL__¤.
%%%% ¡default!¤
Measure.GLOBAL

¤%%% ¡prop!
SCOPE (constant, scalar) is the measure scope ¤__Measure.UNILAYER__¤.
%%%% ¡default!¤
Measure.UNILAYER

¤%%% ¡prop!
PARAMETRICITY (constant, scalar) is the parametricity of the measure ¤__Measure.NONPARAMETRIC__¤.
%%%% ¡default!¤
Measure.NONPARAMETRIC

¤%%% ¡prop!
COMPATIBLE_GRAPHS (constant, classlist) is the list of compatible graphs.
%%%% ¡default!¤
{'GraphWU' 'GraphBU' 'MultigraphBUD' 'MultigraphBUT' 'MultiplexWU' 'MultiplexBU' 'MultiplexBUD' 'MultiplexBUT' 'OrdMxWU' 'OrdMxBU'}

¤%%% ¡prop!
M (result, cell) is the ¤average degree¤.
%%%% ¡calculate!¤
degree = calculateValue@Degree(m, prop); ¥\circled{1}\circlednote{1}{calculates the value of the degree calling its parent \code{Degree}.}¥

g = m.get('G');

degree_av = cell(g.get('LAYERNUMBER'), 1);
parfor li = 1:1:g.get('LAYERNUMBER')
    degree_av(li) = {mean(degree{li})};
end

value = degree_av;
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:degreeav:tests,
	caption={
		{\bf DegreeAv element tests.}
		The \code{tests} section from the element generator \fn{\_DegreeAv.gen.m}.
		\expand{cd:m:degree:tests}
	}
]
¤%% ¡tests!¤

¤%%% ¡excluded_props!¤
[DegreeAv.TEMPLATE DegreeAv.PFM]

¤%%% ¡test!
%%%% ¡name!
GraphWU
%%%% ¡probability!
.01
%%%% ¡code!
B = [
    0   .6  1
    .6  0   0
    1   0   0
    ];

¤known_degree_av = {mean([2 1 1])};¤

g = GraphWU('B', B);

m_outside_g = ¤DegreeAv¤('G', g);
assert(isequal(m_outside_g.get('M'), ¤known_degree_av¤), ...
    [BRAPH2.STR ':¤DegreeAv¤:' BRAPH2.FAIL_TEST], ...
    [class(m_outside_g) ' is not being calculated correctly for ' class(g) '.'])

m_inside_g = g.get('MEASURE', ¤'DegreeAv'¤);
assert(isequal(m_inside_g.get('M'), ¤known_degree_av¤), ...
    [BRAPH2.STR ':¤DegreeAv¤:' BRAPH2.FAIL_TEST], ...
    [class(m_inside_g) ' is not being calculated correctly for ' class(g) '.'])

...¤
\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of Distance}

Now we implement the binodal measure \code{Distance}, again highlighting the differences.

\begin{lstlisting}[
	label=cd:m:degree:header,
	caption={
		{\bf Degree element header.}
		The \code{header} section of generator code for \fn{\_Degree.gen.m} provides the general information about the \code{Degree} element.
	}
]
%% ¡header!
Degree < Measure (m, degree) is the graph degree. ¥\circled{1}\circlednote{1}{The element \code{Degree} is defined as a subclass of \code{Measure}. The moniker will be \code{m}.}¥

%%% ¡description!
The degree of a node is the number of edges connected to the node within a layer. 
Connection weights are ignored in calculations.
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:degree:prop_update,
	caption={
		{\bf Degree element prop update.}
		The \code{props\_update} section of generator code for \fn{\_Degree.gen.m} updates the properties of the \code{Measure} element. This defines the core properties of the measure.
	}
]
%% ¡props_update!

%%% ¡prop!
NAME (constant, string) is the name of the degree.
%%%% ¡default!
'Degree'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the degree.
%%%% ¡default!
'The degree of a node is the number of edges connected to the node within a layer. Connection weights are ignored in calculations.'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the degree.

%%% ¡prop!
ID (data, string) is a few-letter code of the degree.
%%%% ¡default!
'Degree ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of the degree.
%%%% ¡default!
'Degree label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the degree.
%%%% ¡default!
'Degree notes'

%%% ¡prop! ¥\circled{1}\circlednote{1}{Measures have a \emph{shape}: \code{Measure.GLOBAL} (a value for the whole brain graph, e.g., average degree), \code{Measure.NODAL} (a value for each brain region, e.g., degree, or \code{Measure.BINODAL} (a value for each couple of brain regions, e.g., distance between couples of nodes).}¥
SHAPE (constant, scalar) is the measure shape __Measure.NODAL__.
%%%% ¡default!
Measure.NODAL

%%% ¡prop! ¥\circled{2}\circlednote{2}{Measures have a \emph{scope}: \code{Measure.SUPERGLOBAL} (a result for the whole multi-layer graph, e.g., overlapping strength), \code{Measure.UNILAYER} (a result for each layer, e.g., average strength), or \code{Measure.BILAYER} (a result for each couple of layers).}¥
SCOPE (constant, scalar) is the measure scope __Measure.UNILAYER__.
%%%% ¡default!
Measure.UNILAYER

%%% ¡prop! ¥\circled{3}\circlednote{3}{Measures are either \code{Measure.NONPARAMETRIC} (the usual case) or \code{Measure.PARAMETRIC} (depending on some parameter).}¥
PARAMETRICITY (constant, scalar) is the parametricity of the measure __Measure.NONPARAMETRIC__.
%%%% ¡default!
Measure.NONPARAMETRIC

%%% ¡prop! ¥\circled{4}\circlednote{4}{Each measure has a list of compatible graphs for which the measure can be used.}¥
COMPATIBLE_GRAPHS (constant, classlist) is the list of compatible graphs.
%%%% ¡default!
{'GraphWU' 'GraphBU' 'MultigraphBUD' 'MultigraphBUT' 'MultiplexWU' 'MultiplexBU' 'MultiplexBUD' 'MultiplexBUT' 'OrdMxWU' 'OrdMxBU'}

%%% ¡prop! ¥\circled{5}\circlednote{5}{The property \code{M} contains the code to be executed to calculate the measure. Here is where most of the action happens.}¥
M (result, cell) is the degree.
%%%% ¡calculate!
g = m.get('G'); ¥\circled{6}\circlednote{6}{retrieves the graph from the property \code{G} of the measure \code{m}.}¥
A = g.get('A'); ¥\circled{7}\circlednote{7}{retrieves the cell with the adjacency matrix (for graph) or 2D-cell array (for multigraph, multiplex, etc.).}¥

degree = cell(g.get('LAYERNUMBER'), 1); ¥\circled{8}\circlednote{8}{preallocates the variable to contain the result of the measure calculation.}¥

parfor li = 1:1:g.get('LAYERNUMBER')
    Aii = A{li, li};
    Aii = binarize(Aii); ¥\circled{9}\circlednote{9}{binarizes the adjacency matrix (removing diagonal).}¥
    degree(li) = {sum(Aii, 2)}; ¥\circled{10}\circlednote{10}{calculates the degree of the node for layer \code{li}.}¥
end

value = degree; ¥\circled{11}\circlednote{11}{returns the calcualted value of the measure \code{degree} assigning it to the output variable \code{value}.}¥
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:degree:tests,
	caption={
		{\bf Degree element tests.}
		The \code{tests} section from the element generator \fn{\_Degree.gen.m}.
		A test should be prepared for each graph with which the measure is compatible. The test should at least verify in some simple cases that the value of the measure is correct 
	}
]
%% ¡tests!

%%% ¡excluded_props! ¥\circled{1}\circlednote{1}{List of properties that are excluded from testing.}¥
[Degree.TEMPLATE Degree.PFM] 

%%% ¡test! ¥\circled{2}\circlednote{2}{Test for \code{GraphWU}. Similar tests should be implemented for each graph compatible with the measure.}¥
%%%% ¡name!
GraphWU
%%%% ¡probability! ¥\circled{3}\circlednote{3}{assings a low test execution probability.}¥
.01
%%%% ¡code!
B = [
    0   .6  1
    .6  0   0
    1   0   0
    ];

known_degree = {[2 1 1]'}; ¥\circled{4}\circlednote{4}{is the expected value of the measure calculated by external means.}¥

g = GraphWU('B', B); ¥\circled{5}\circlednote{5}{creates the graph.}¥

m_outside_g = Degree('G', g); ¥\circled{6}\circlednote{6}{creates the measure.}¥
assert(isequal(m_outside_g.get('M'), known_degree), ... ¥\circled{7}\circlednote{7}{tests that the value of the measure coicides with its expected value.}¥ 
    [BRAPH2.STR ':Degree:' BRAPH2.FAIL_TEST], ...
    [class(m_outside_g) ' is not being calculated correctly for ' class(g) '.'])

m_inside_g = g.get('MEASURE', 'Degree'); ¥\circled{8}\circlednote{8}{extracts the measure from the graph.}¥
assert(isequal(m_inside_g.get('M'), known_degree), ... ¥\circled{8}\circlednote{8}{tests that the value of the measure extracted from the graph coicides with its expected value.}¥
    [BRAPH2.STR ':Degree:' BRAPH2.FAIL_TEST], ...
    [class(m_inside_g) ' is not being calculated correctly for ' class(g) '.'])

¤...¤
\end{lstlisting}

%\bibliography{sample-handout}
%\bibliographystyle{plainnat}

\end{document}