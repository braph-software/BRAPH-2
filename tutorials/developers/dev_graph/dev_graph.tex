\documentclass{tufte-handout}
\usepackage{../braph2_dev}
%\geometry{showframe} % display margins for debugging page layout

\title{Implement a New Graph}

\author[The BRAPH~2 Developers]{The BRAPH~2 Developers}

\begin{document}

\maketitle

\begin{abstract}
\noindent
This is the developer tutorial for implementing a new graph. 
In this tutorial, you will learn how to create the generator file \fn{*.gen.m} for a new graph, which can then be compiled by \code{braph2genesis}. All graphs are (direct or indirect) extensions of the base element \code{Graph}. Here, you will use as examples the graphs \code{GraphBD} (Binary Directed graph), \code{MultilayerWU} (Weighted Undirected multilayer graph), \code{MultiplexBUT} (Binary Undirected multiplex at fixed Thresholds), and \code{OrdMxBUT} (Binary Undirected ordinal multiplex with fixed Thresholds).
\end{abstract}

\tableofcontents

\clearpage
\section{Implementation of unilayer graphs}

\subsection{Unilayer binary directed graph (\code{GraphBD})}

You will start by implementing in detail \code{GraphBD}, which  is a direct extension of  \code{Graph}.
A unilayer graph is constituted by nodes connected by edges, where the can be either 0 (absence of connection) or 1 (existence of connection).

\begin{lstlisting}[
	label=cd:m:GraphBD:header,
	caption={
		{\bf GraphBD element header.}
		The \code{header} section of the generator code in \fn{\_GraphBD.gen.m} provides the general information about the \code{GraphBD} element.
		}
]
%% ¡header!
GraphBD < Graph (g, binary directed graph) is a binary directed graph. ¥\circled{1}\circlednote{1}{ defines \code{GraphBD} as a subclass of \code{Graph}. The moniker will be \code{g}.}¥

%%% ¡description! ¥\circled{2}\circlednote{2}{ provides a description of this graph.}¥
In a binary directed (BD) graph, the edges are directed and they can be either 0 (absence of connection) or 1 (existence of connection).

%%% ¡build! ¥\circled{3}\circlednote{3}{ defines the build number of the graph element.}¥
1
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:GraphBD:prop_update,
	caption={
		{\bf GraphBD element prop update.}
		The \code{props\_update} section of the generator code in \fn{\_GraphBD.gen.m} updates the properties of the \code{Graph} element. This defines the core properties of the graph.
	}
]
%% ¡props_update!

%%% ¡prop!
NAME (constant, string) is the name of the binary directed graph.
%%%% ¡default!
'GraphBD'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the  binary directed graph.
%%%% ¡default!
'In a binary directed (BD) graph, the edges are directed and they can be either 0 (absence of connection) or 1 (existence of connection).'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the  binary directed graph.

%%% ¡prop!
ID (data, string) is a few-letter code of the  binary directed graph.
%%%% ¡default!
'GraphBD ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of the binary directed graph.
%%%% ¡default!
'GraphBD label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the binary directed graph.
%%%% ¡default!
'GraphBD notes'

%%% ¡prop! ¥\circled{1}\circlednote{1}{ defines the \emph{graph type}: \code{Graph.GRAPH} (single layer), \code{Graph.MULTIGRAPH} (multiple unconnected layers), \code{Graph.MULTILAYER} (multiple layers), \code{Graph.ORDERED\_MULTILAYER} (multiple subsequent layers) \code{Graph.MULTIPLEX} (multilayer with connections between corresponding nodes), and \code{Graph.ORDERED\_MULTIPLEX} (multilayer with connections between corresponding nodes in subsequent layers).}¥
GRAPH_TYPE (constant, scalar) returns the graph type __Graph.GRAPH__.
%%%% ¡default!
Graph.GRAPH

%%% ¡prop! ¥\circled{2}\circlednote{2}{ defines the \emph{graph connectivity}: \code{Graph.BINARY} (0 or 1) or \code{Graph.WEIGHTED}.}¥
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type __Graph.BINARY__.
%%%% ¡default!
value = Graph.BINARY;

%%% ¡prop! ¥\circled{3}\circlednote{3}{ defines the \emph{edge directionality}: \code{Graph.DIRECTED} or \code{Graph.UNDIRECTED}.}¥
DIRECTIONALITY_TYPE  (query, smatrix) returns the directionality type __Graph.DIRECTED__.
%%%% ¡default! 
value = Graph.DIRECTED;

%%% ¡prop! ¥\circled{4}\circlednote{4}{ defines the \emph{graph self-connectivity}: \code{Graph.NONSELFCONNECTED} or \code{Graph.SELFCONNECTED}.}¥
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__.
%%%% ¡default!
value = Graph.NONSELFCONNECTED;

%%% ¡prop! ¥\circled{5}\circlednote{5}{ defines the \emph{graph negativity}: \code{Graph.NONNEGATIVE} or \code{Graph.NEGATIVE}.}¥
NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__.
%%%% ¡default!
value = Graph.NONNEGATIVE;

%%% ¡prop! ¥\circled{6}\circlednote{6}{ The property \code{A} contains the supra-adjacency matrix of the graph, which is calculated by the code under \code{¡calculate!}.}¥
A (result, cell) is the binary adjacency matrix of the binary directed graph.
%%%% ¡calculate!
B = g.get('B'); ¥\circled{7}\circlednote{7}{ retrieves the adjacency matrix of the graph \code{B}, defined in the new properties below.}¥

B = dediagonalize(B);  ¥\circled{8}\circlednote{8}{, \circled{9}, and \circled{10} condition the adjaciency matrix removing the diagonal elements, making it semidefinte positive, and binarizing it. A list of useful functions is: \code{diagonalize} (removes the off-diagonal), \code{dediagonalize} (removes the diagonal), \code{binarize} (binarizes with threshold=0), \code{semipositivize} (removes negative weights), \code{standardize} (normalizes between 0 and 1) or \code{symmetrize} (symmetrizes the matrix). Use the MatLab help to see additional functionalities.}¥
B = semipositivize(B, 'SemipositivizeRule', g.get('SEMIPOSITIVIZE_RULE')); ¥\circled{9}¥
B = binarize(B); ¥\circled{10}¥

A = {B}; ¥\circled{11}\circlednote{11}{ preallocates the adjacency matrix to be calculated.}¥
if g.get('RANDOMIZE') ¥\circled{12}\circlednote{12}{ randomizes adjacency matrix when \code{'RANDOMIZE'} is \code{true} by calling the function of the graph named \code{RANDOMIZATION}}¥
	random_A = g.get('RANDOMIZATION', A);
	A = {random_A};
end
value = A; ¥\circled{13}\circlednote{13}{ returns the calculated graph \code{A} assigning it to the output variable \code{value}.}¥
%%%% ¡gui! ¥\circled{14}\circlednote{14}{ employs the property panel \code{PanelPropCell} to be employed to visualize \code{A}, setting also its properties.}¥
pr = PanelPropCell('EL', g, 'PROP', GraphBD.A, ... 
	'TABLE_HEIGHT', s(40), ... 
	'XSLIDERSHOW', false, ... 
	'YSLIDERSHOW', false, ...  
	'ROWNAME' , g.getCallback('ANODELABELS'), ... 
	'COLUMNNAME', g.getCallback('ANODELABELS'));

%%% ¡prop! ¥\circled{15}\circlednote{15}{ determines the list of compatible figures.}¥
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures('GraphBD')
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:GraphBD:props,
	caption={
		{\bf GraphBD element props.}
		The \code{props} section of the generator code in \fn{\_GraphBD.gen.m} defines the properties to be used in \code{GraphBD}.
	}
]
%% ¡props!

%%% ¡prop!¥\circled{1}\circlednote{1}{ contains the input adjacency matrix  \code{B}, which is typically weighted and directed.}¥
B (data, smatrix) is the input graph adjacency matrix.
%%%% ¡gui! ¥\circled{2}\circlednote{2}{ defines the property panel \code{PanelPropMatrix} to plot this property with a table.}¥
pr = PanelPropMatrix('EL', g, 'PROP', GraphBD.B, ... 
	'TABLE_HEIGHT' , s(40), ...
	'ROWNAME' , g.getCallback('ANODELABELS'), ... 
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});

%%% ¡prop! ¥\circled{3}\circlednote{3}{ defines the semi-positivation rule (i.e., how to remove the negative edges) to be used when generating the adjacency matrix \code{A} from the intput property \code{B}. The admissible options are: \code{'zero'} (default, convert negative values to zeros) or \code{'absolute'} (convert negative values to absolute value).}¥
SEMIPOSITIVIZE_RULE (parameter, option) determines how to remove the negative edges.
%%%% ¡settings!
{'zero', 'absolute'}

%%% ¡prop!¥\circled{4}\circlednote{4}{ defines the number of attempts that will be used for each edge when calling \code{RANDOMIZATION}.}¥
ATTEMPTSPEREDGE (parameter, scalar) is the attempts to rewire each edge.
%%%% ¡default!
5

%%% ¡prop!¥\circled{5}\circlednote{5}{ randomizes the adjacency matrix contained in \code{cell}.}¥
RANDOMIZATION (query, cell) randomizes matrix contained in the cell.
%%%% ¡calculate!
rng(g.get('RANDOM_SEED'), 'twister')

if isempty(varargin) ¥\circled{6}\circlednote{6}{ returns empty cell is the input is an empty cell.}¥
	value = {};
	return
end

A = cell2mat(varargin{1});
attempts_per_edge = g.get('ATTEMPTSPEREDGE');
% remove self connections
A(1:length(A)+1:numel(A)) = 0;
[I_edges, J_edges] = find(A);  ¥\circled{7}\circlednote{7}{ finds number of edges in the matrix (different from zero).}¥
E = length(I_edges); ¥\circled{8}\circlednote{8}{ returns number of edges in the matrix (different from zero).}¥

if E == 0 ¥\circled{9}\circlednote{9}{ returns same input matrix if it is all zeros.}¥
	value = A;
	swaps = 0;
	return
end

if E == 1 ¥\circled{10}\circlednote{10}{ randomizes the edge when there is only one edge in the input matrix.}¥
	r_ab = A(I_edges(1), J_edges(1));
	A(I_edges(1), J_edges(1)) = 0;
	selected_nodes = randperm(size(A, 1), 2);
	A(selected_nodes(1), selected_nodes(2)) = r_ab;
	value = A;
	swaps = 1;
	return
end

random_A = A;
swaps = 0; % number of successful edge swaps
for attempt = 1:1:attempts_per_edge*E ¥\circled{11}\circlednote{11}{ randomizes edges in the matrix when more than one edge (non-zero) were found in the input matrix.}¥

	selected_edges = randperm(E,2); ¥\circled{12}\circlednote{12}{ takes two random edges.}¥
	node_start_1 = I_edges(selected_edges(1));
	node_end_1 = J_edges(selected_edges(1));
	node_start_2 = I_edges(selected_edges(2));
	node_end_2 = J_edges(selected_edges(2));

	r_1 = random_A(node_start_1, node_end_1); ¥\circled{13}\circlednote{13}{ saves the values of the selected random edges (this is important when the property \code{RANDOMIZATION} is used by weighted graphs).}¥
	r_2 = random_A(node_start_2, node_end_2);

	if ~random_A(node_start_1, node_end_2) && ...
	~random_A(node_start_2, node_end_1) && ...
	node_start_1~=node_start_2 && ...
	node_end_1~=node_end_2 && ...
	node_start_1~=node_end_2 && ...
	node_start_2~=node_end_1
	
		% erase old edges ¥\circled{14}\circlednote{14}{ deletes edges in the old positions.}¥
		random_A(node_start_1, node_end_1) = 0;
		random_A(node_start_2, node_end_2) = 0;

		% write new edges ¥\circled{15}\circlednote{15}{ sets values of edges in the new random positions.}¥
		random_A(node_start_1, node_end_2) = r_1;
		random_A(node_start_2, node_end_1) = r_2;
		
		% update edge list
		J_edges(selected_edges(1)) = node_end_2;
		J_edges(selected_edges(2)) = node_end_1;

		swaps = swaps+1;
	end
end
value = random_A;
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:GraphBD:tests,
	caption={
		{\bf GraphBD element tests.}
		The \code{tests} section in the element generator \fn{\_GraphBD.gen.m}.
		A general test should be prepared to test the properties of the graph  when it is empty and full. Furthermore, additional tests should be prepared for the defined rules (one test per rule).
	}
]			
%% ¡tests!

%%% ¡excluded_props!  ¥\circled{1}\circlednote{1}{ List of properties that are excluded from testing.}¥
[GraphBD.PFGA GraphBD.PFGH]

%%% ¡test!
%%%% ¡name!
Constructor - Empty  ¥\circled{2}\circlednote{2}{ checks that an empty \code{GraphBD} graph is constructing well.}¥
%%%% ¡probability! ¥\circled{3}\circlednote{3}{ assigns a low test execution probability.}¥
.01
%%%% ¡code!
B = []; ¥\circled{4}\circlednote{4}{ initializes an empty input adjacency matrix \code{B}.}¥
g = GraphBD('B', B);¥\circled{5}\circlednote{5}{ constructs the \code{GraphBD} graph from the initialized \code{B}.}¥

g.get('A_CHECK'); ¥\circled{6}\circlednote{6}{ performs the corresponding checks for the format of the adjacency matrix \code{A}: \code{GRAPH\_TYPE}, \code{CONNECTIVITY\_TYPE}, \code{DIRECTIONALITY\_TYPE}, \code{SELFCONNECTIVITY\_TYPE}, and \code{NEGATIVITY\_TYPE}.}¥

A = {binarize(semipositivize(dediagonalize(B)))}; ¥\circled{7}\circlednote{7}{ calculates the value of the graph by applying the corresponding functions.}¥
assert(isequal(g.get('A'), A), ...¥\circled{8}\circlednote{8}{ tests that the value of generated graph calculated by applying the functions coincides with the expected value.}¥
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD is not constructing well.')

%%% ¡test!
%%%% ¡name!
Constructor - Full ¥\circled{9}\circlednote{9}{ checks that a full \code{GraphBD} graph is constructing well.}¥
%%%% ¡probability!
.01
%%%% ¡code!
B = randn(randi(10)); ¥\circled{10}\circlednote{10}{ generates a random input adjacency matrix \code{B}.}¥
g = GraphBD('B', B);

g.get('A_CHECK')

A = {binarize(semipositivize(dediagonalize(B)))};
assert(isequal(g.get('A'), A), ...
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD is not constructing well.')

%%% ¡test!
%%%% ¡name!
Semipositivize Rules ¥\circled{11}\circlednote{11}{ checks the \code{SEMIPOSITIVIZE\_RULE} on the \code{GraphBD} graph.}¥
%%%% ¡probability!
.01 ¥\circled{3}¥
%%%% ¡code!
B = [ ¥\circled{12}\circlednote{12}{ generates an input adjacency matrix with negative weights.}¥
	-2 -1 0 1 2
	-1 0 1 2 -2
	0 1 2 -2 -1
	1 2 -2 -1 0
	2 -2 -1 0 1
	];

g0 = GraphBD('B', B);  ¥\circled{13}\circlednote{13}{ constructs the \code{GraphBD} graph from the initialized \code{B} with default RULE for \code{SEMIPOSITIVIZE\_RULE}.}¥
A0 = {[ ¥\circled{14}\circlednote{14}{ provides the expected value of \code{A} calculated by external means.}¥
	0 0 0 1 1
	0 0 1 1 0
	0 1 0 0 0
	1 1 0 0 0
	1 0 0 0 0
	]};
assert(isequal(g0.get('A'), A0), ... 
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD is not constructing well.')

g_zero = GraphBD('B', B, 'SEMIPOSITIVIZE_RULE', 'zero'); ¥\circled{15}\circlednote{15}{ constructs the \code{GraphBD} graph from the initialized \code{B} with RULE = 'zero' for \code{SEMIPOSITIVIZE\_RULE}.}¥
A_zero = {[
	0 0 0 1 1
	0 0 1 1 0
	0 1 0 0 0
	1 1 0 0 0
	1 0 0 0 0
	]};
assert(isequal(g_zero.get('A'), A_zero), ...
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD is not constructing well.')

g_absolute = GraphBD('B', B, 'SEMIPOSITIVIZE_RULE', 'absolute'); ¥\circled{16}\circlednote{16}{ constructs the \code{GraphBD} graph from the initialized \code{B} with RULE = 'absolute' for \code{SEMIPOSITIVIZE\_RULE}.}¥
A_absolute = {[
	0 1 0 1 1
	1 0 1 1 1
	0 1 0 1 1
	1 1 1 0 0
	1 1 1 0 0
	]};
assert(isequal(g_absolute.get('A'), A_absolute), ...
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD is not constructing well.')
	
%%% ¡test!
%%%% ¡name!
Randomize Rules ¥\circled{17}\circlednote{17}{ tests that \code{RANZOMIZATION} works properly.}¥
%%%% ¡probability!
.01
%%%% ¡code!
B = randn(10);

g = GraphBD('B', B);
g.set('RANDOMIZE', true);
g.set('ATTEMPTSPEREDGE', 4);

A = g.get('A');

assert(isequal(size(A{1}), size(B)), ... ¥\circled{18}\circlednote{18}{ tests that \code{RANZOMIZATION} returns a matrix with same size.}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD Randomize is not functioning well.')

g2 = GraphBD('B', B);
g2.set('RANDOMIZE', false);
g2.set('ATTEMPTSPEREDGE', 4);
A2 = g2.get('A');
random_A = g2.get('RANDOMIZATION', A2);

if all(A2{1}==0, "all")¥\circled{19}\circlednote{19}{ tests that \code{RANZOMIZATION} returns a matrix of zeros when input matrix is all zeros.}¥
	assert(isequal(A2{1}, random_A), ...
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD Randomize is not functioning well.')
elseif isequal((length(A2{1}).^2)- length(A2{1}), sum(A2{1}==1, "all"))¥\circled{20}\circlednote{20}{ tests that \code{RANZOMIZATION} returns a matrix of ones when input matrix is all ones (except diagonal).}¥
	assert(isequal(A2{1}, random_A), ...
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD Randomize is not functioning well.')
else ¥\circled{21}\circlednote{21}{ tests that new random matrix is different from original one.}¥
	assert(~isequal(A2{1}, random_A), ...
	[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
	'GraphBD Randomize is not functioning well.')
end

assert(isequal(numel(find(A2{1})), numel(find(random_A))), ... ¥\circled{22}\circlednote{22}{ tests that new random matrix has the same number of nodes as the original one}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD Randomize is not functioning well.')

deg_A = sum(A2{1}, 2);
deg_B = sum(random_A, 2);
[h, p, ks2stat] = kstest2(deg_A, deg_B);

assert(isequal(0, h), ... % ¥\circled{23}\circlednote{23}{ tests that new random matrix has the same degree distribution as the original one}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD Randomize is not functioning well.')

\end{lstlisting}


\clearpage


\section{Implementation of multilayer graphs}

\subsection{Weighted directed multilayer graph (\code{MultilayerWD})}

You can now use \code{GraphBD} as the basis to implement the \code{MultilayerWD} graph. 
{%TEX
The parts of the code that are modified are highlighted.
}%TEX
A multilayer graph allows connections between any nodes across the multiple layers, where all layers are interconnected following a categorical fashion.

\begin{lstlisting}[
	label=cd:m:MultilayerWD:header,
	caption={
		{\bf MultilayerWD element header.}
		The \code{header} section of generator code in \fn{\_MultilayerWD.gen.m} provides the general information about the \code{MultilayerWD} element.
		\expand{cd:m:GraphBD:header}
	}
]
¤%% ¡header!¤
MultilayerWD ¤< Graph¤ (g, multilayer weighted directed graph) is a multilayer weighted directed graph.

¤%%% ¡description!¤
In a multilayer weighted directed (WD) graph, layers could have different number of nodes with within-layer weighted directed edges, associated with a real number between 0 and 1 and indicating the strength of the connection. The connectivity matrices are symmetric (within layer). All node connections are allowed between layers.

¤%%% ¡build!¤
1
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultilayerWD:prop_update,
	caption={
		{\bf MultilayerWD element prop update.}
		The \code{props\_update} section of the generator code in \fn{\_MultilayerWD.gen.m} updates the properties of \code{MultilayerWD}.
		\expand{cd:m:GraphBD:prop_update}
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'In a multilayer weighted directed (WD) graph, layers could have different number of nodes with within-layer weighted directed edges, associated with a realnumber between 0 and 1 and indicating the strength of the connection. The connectivity matrices are symmetric (within layer). All node connections are allowed between layers.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of the ¤multilayer weighted directed graph¤.¤

¤%%% ¡prop!
ID (data, string) is a few-letter code of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD notes'

¤%%% ¡prop!
GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.MULTILAYER__.
%%%% ¡default!
Graph.MULTILAYER

¤%%% ¡prop!
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type¤ __Graph.WEIGHTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
layernumber = 1;
else
layernumber = varargin{1};
end
value = Graph.WEIGHTED * ones(layernumber);

¤%%% ¡prop!
DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type¤ __Graph.DIRECTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.DIRECTED * ones(layernumber);

¤%%% ¡prop!
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type¤ __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.SELFCONNECTED * ones(layernumber);
value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                

¤%%% ¡prop!
NEGATIVITY_TYPE (query, smatrix) returns the negativity type ¤__Graph.NONNEGATIVE__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.NONNEGATIVE * ones(layernumber);

¤%%% ¡prop!
A (result, cell) is the cell containing¤ the within-layer weighted adjacency
matrices of the multilayer weighted directed graph and the connections
between layers.

¤%%%% ¡calculate!
B = g.get('B'); ¤
L = length(B); 
A = cell(L, L);
for i = 1:1:L ¥\circled{1}\circlednote{1}{ For each layer in \code{MultilayerWD} graph, the corresponding functions are applied as in the notes \circled{8}, \circled{9}, and  \circled{10} of \Coderef{cd:m:GraphBD:prop_update}.}¥
	M = dediagonalize(B{i,i}); 
	M = semipositivize(M, 'SemipositivizeRule', g.get('SEMIPOSITIVIZE_RULE'));
	M = standardize(M, 'StandardizeRule', g.get('STANDARDIZE_RULE'));  
	A(i, i) = {M};
	if ~isempty(A{i, i})
		for j = i+1:1:L
			M = semipositivize(B{i,j}, 'SemipositivizeRule', 	g.get('SEMIPOSITIVIZE_RULE')); 
			M = standardize(M, 'StandardizeRule', 	g.get('STANDARDIZE_RULE'));  
			A(i, j) = {M};
			M = semipositivize(B{j,i}, 'SemipositivizeRule', 	g.get('SEMIPOSITIVIZE_RULE')); 
			M = standardize(M, 'StandardizeRule', 	g.get('STANDARDIZE_RULE'));  
			A(j, i) = {M};
		end
	end
end
¤if g.get('RANDOMIZE')
	A = g.get('RANDOMIZATION', A);
end
value = A;¤
¤%%%% ¡gui!¤
pr = PanelPropCell('EL', g, 'PROP', ¤MultilayerWD.A, ...
	¤'TABLE_HEIGHT', s(40), ...¤
	'XYSLIDERLOCK', true, ... 
	¤'XSLIDERSHOW', false, ...
	'YSLIDERSHOW', true, ...¤
	'YSLIDERLABELS', g.getCallback('ALAYERLABELS'), ...
	'YSLIDERWIDTH', s(5), ...
	¤'ROWNAME', g.getCallback('ANODELABELS'), ...
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});

%%% ¡prop!
PARTITIONS (result, rvector) returns the number of layers in the partitions of the graph.
%%%% ¡calculate!
value = ones(1, g.get('LAYERNUMBER'));

%%% ¡prop! ¥\circled{2}\circlednote{2}{ These are some properties of the graph adjacency matrix \code{A} used in its  visualization. The list of properties that can be used are: \code{ALAYERTICKS} (to set ticks for each layer according to the layer number), \code{ALAYERLABELS} (to set labels for each layer), and \code{ANODELABELS} (to set the nodal labels for each layer)).}¥
ALAYERLABELS (query, stringlist) returns the layer labels to be used by the slider.
%%%% ¡calculate!
alayerlabels = g.get('LAYERLABELS'); ¥\circled{3}\circlednote{3}{ returns the labels of the graph layers provided by the user.}¥
if isempty(alayerlabels) && ~isa(g.getr('A'), 'NoValue') % ensures that it's not unecessarily calculated
	alayerlabels = cellfun(@num2str, num2cell([1:1:g.get('LAYERNUMBER')]), 'uniformoutput', false); ¥\circled{4}\circlednote{4}{ constructs the labels of the layers based on the number of the layer (in case no layer labels were provided by the user).}¥
end
value = alayerlabels;

¤%%% ¡prop!
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures¤('MultilayerWD')
\end{lstlisting}



\begin{lstlisting}[
	label=cd:m:MultilayerWD:props,
	caption={
	{\bf MultilayerWD element props.}
	The \code{props} section of the generator code for \fn{\_MultilayerWD.gen.m} defines the properties to be used in \code{MultilayerWD}.
	\expand{cd:m:GraphBD:props}
	}
]
%% ¡props!

%%% ¡prop!
B (data, cell) is the input cell containing the multilayer adjacency matrices.
%%%% ¡default!
{[] []; [] []}
%%%% ¡gui! ¥\circled{1}\circlednote{1}{ Same as in note \circled{2} of \Coderef{cd:m:GraphBD:props}.}¥
pr = PanelPropCell('EL', g, 'PROP', MultilayerWD.B, ...
	'TABLE_HEIGHT', s(40), ...
	'XSLIDERSHOW', true, ...
	'XSLIDERLABELS', g.get('LAYERLABELS'), ...
	'XSLIDERHEIGHT', s(3.5), ...
	'YSLIDERSHOW', false, ...
	'ROWNAME', g.getCallback('ANODELABELS'), ...
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});


¤%%% ¡prop!
SEMIPOSITIVIZE_RULE (parameter, option) determines how to remove the negative edges.
%%%% ¡settings!
{'zero', 'absolute'}¤

%%% ¡prop!  ¥\circled{2}\circlednote{2}{ Same as in  note \circled{3} of \Coderef{cd:m:GraphBD:props}.}¥
STANDARDIZE_RULE (parameter, option) determines how to normalize the weights between 0 and 1.
%%%% ¡settings!
{'threshold' 'range'}

¤%%% ¡prop!
ATTEMPTSPEREDGE (parameter, scalar) is the attempts to rewire each edge.
%%%% ¡default!
5¤

%%% ¡prop!
NUMBEROFWEIGHTS (parameter, scalar) specifies the number of weights sorted at the same time.  ¥\circled{3}\circlednote{3}{ defines the number of weights that will be sorted at the same time when using \code{RANDOMIZATION}.}¥
%%%% ¡default!
10

¤%%% ¡prop!
RANDOMIZATION (query, cell) is the attempts to rewire each edge.
%%%% ¡calculate!
rng(g.get('RANDOM_SEED'), 'twister')

if isempty(varargin)
	value = {};
	return
end

A = varargin{1};
attempts_per_edge = g.get('ATTEMPTSPEREDGE');¤

for i = 1:length(A) ¥\circled{4}\circlednote{4}{ iterates over each layer in \code{MultilayerWD} to randomize it.}¥
	tmp_a = A{i,i};

	tmp_g = GraphWD(); ¥\circled{5}\circlednote{5}{ initizalizes empty \code{GraphWD} to get \code{RANDOMIZATION} property from it.}¥
	tmp_g.set('ATTEMPTSPEREDGE', g.get('ATTEMPTSPEREDGE'));
	tmp_g.set('NUMBEROFWEIGHTS', g.get('NUMBEROFWEIGHTS'));
	random_A = tmp_g.get('RANDOMIZATION', {tmp_a});
	A{i, i} = random_A;
end
value = A;

\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultilayerWD:tests,
	caption={
		{\bf MultilayerWD element tests.}
		The \code{tests} section from the element generator \fn{\_MultilayerWD.gen.m}.
		\expand{cd:m:GraphBD:tests}
	}
]
¤%% ¡tests!

%%% ¡excluded_props!¤
[MultilayerWD.PFGA MultilayerWD.PFGH]

¤%%% ¡test!
%%%% ¡name!
Constructor - Full
%%%% ¡probability!
.01
%%%% ¡code!¤
B1 = rand(randi(10));
B2 = rand(randi(10));
B3 = rand(randi(10));
B12 = rand(size(B1, 1),size(B2, 2));
B13 = rand(size(B1, 1),size(B3, 2));
B23 = rand(size(B2, 1),size(B3, 2));
B21 = rand(size(B2, 1),size(B1, 2));
B31 = rand(size(B3, 1),size(B1, 2));
B32 = rand(size(B3, 1),size(B2, 2));
B = {
	B1                           B12                            B13
	B21                          B2                             B23
	B31                          B32                            B3
};
g = MultilayerWD('B', B);
¤g.get('A_CHECK')¤
A1 = standardize(semipositivize(dediagonalize(B1)));
A2 = standardize(semipositivize(dediagonalize(B2)));
A3 = standardize(semipositivize(dediagonalize(B3)));
A12 = standardize(semipositivize(B12));
A13 = standardize(semipositivize(B13));
A23 = standardize(semipositivize(B23));
A21 = standardize(semipositivize(B21));
A31 = standardize(semipositivize(B31));
A32 = standardize(semipositivize(B32));
B{1,1} = A1;
B{2,2} = A2;
B{3,3} = A3;
B{1,2} = A12;
B{1,3} = A13;
B{2,3} = A23;
B{2,1} = A21;
B{3,1} = A31;
B{3,2} = A32;
A = B;
¤assert(isequal(g.get('A'), A), ...¤
	¤[BRAPH2.STR ':¤ MultilayerWD:¤ ' BRAPH2.FAIL_TEST], ...¤
	'MultilayerWD  is not constructing well.')
	
¤%%% ¡test!
%%%% ¡name!
Randomize Rules
%%%% ¡probability!
.01
%%%% ¡code!¤
B1 = rand(randi(10));
B2 = rand(randi(10));
B3 = rand(randi(10));
B12 = rand(size(B1, 1),size(B2, 2));
B13 = rand(size(B1, 1),size(B3, 2));
B23 = rand(size(B2, 1),size(B3, 2));
B21 = rand(size(B2, 1),size(B1, 2));
B31 = rand(size(B3, 1),size(B1, 2));
B32 = rand(size(B3, 1),size(B2, 2));
B = {
	B1                           B12                            B13
	B21                          B2                             B23
	B31                          B32                            B3
};
g = MultilayerWD('B', B);
¤g.set('RANDOMIZE', true);
g.set('ATTEMPTSPEREDGE', 4);
g.get('A_CHECK')

A = g.get('A')¤

¤assert(isequal(size(A{1}), size(B{1})), ...
[BRAPH2.STR ¤'MultilayerWD:' ¤BRAPH2.FAIL_TEST], ... 'MultilayerWD Randomize is not functioning well.')¤

g2 = MultilayerWD('B', B);
¤g2.set('RANDOMIZE', true);
g2.set('ATTEMPTSPEREDGE', 4);
g2.get('A_CHECK')
A2 = g2.get('A');
random_A = g2.get('RANDOMIZATION', A2);¤

for i = 1:length(A2) ¥\circled{1}\circlednote{1}{ tests \code{RANDOMIZATION} as in \Coderef{cd:m:GraphBD:tests} for each layer in \code{A2}.}¥
	¤if all(A2{i, i}==0, "all") %if all edges are zero, the new random matrix is all zeros
		assert(isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':MultilayerWD:' BRAPH2.FAIL_TEST], ...
		'MultilayerWD Randomize is not functioning well.')
	elseif isequal((length(A2{i, i}).^2)- length(A2{i, i}), sum(A2{i, i}==1, "all")) %if all nodes (except diagonal) are one, the random matrix is the same as original
		assert(isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':MultilayerWD:' BRAPH2.FAIL_TEST], ...
		'MultilayerWD Randomize is not functioning well.')
	else
		assert(~isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':MultilayerWD:' BRAPH2.FAIL_TEST], ...
		'MultilayerWD Randomize is not functioning well.')
	end
assert(isequal(numel(find(A2{i, i})), numel(find(random_A{i, i}))), ... % check same number of nodes
[BRAPH2.STR ':MultilayerWD:' BRAPH2.FAIL_TEST], ...
'MultilayerWD Randomize is not functioning well.')¤
end
\end{lstlisting}

\clearpage

\subsection{Binary undirected multilayer graph with fixed thresholds (\code{MultiplexBUT})}

Now you will implement the \code{MultiplexBUT} graph building on the previous codes \code{GraphBD} and \code{MultilayerWD}. 
{%TEX
Again, the differences will be highlighted.
}%TEX
A multiplex graph is a type of multilayer graph where interlayer edges are allowed only between homologous nodes. In this case, the layers follow a categorical architecture, which means that all layers are interconnected.

\begin{lstlisting}[
	label=cd:m:MultiplexBUT:header,
	caption={
		{\bf MultiplexBUT element header.}
		The \code{header} section of the generator code in \fn{\_MultiplexBUT.gen.m} provides the general information about the \code{MultiplexBUT} element.
		\expand{cd:m:GraphBD:header}
	}
]
¤%% ¡header!¤
MultiplexBUT < MultiplexWU (g, binary undirected multiplex with fixed thresholds) is a binary undirected multiplex with fixed thresholds. ¥\circled{1}\circlednote{1}{ MultiplexBUT is a child of \code{MultiplexWU}, which in turn derives from \code{Graph}.}¥
	
¤%%% ¡description!¤
In a binary undirected multiplex with fixed thresholds (BUT), the layers are those of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds.The supra-connectivity matrix has a number of partitions equal to the number of thresholds.

¤%%% ¡build!¤
1
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultiplexBUT:prop_update,
	caption={
		{\bf MultiplexBUT element prop update.}
		The \code{props\_update} section of the generator code in \fn{\_MultiplexBUT.gen.m} updates the properties of \code{MultiplexBUT}.
		\expand{cd:m:GraphBD:prop_update}
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of the ¤binary undirected multiplex with fixed thresholds¤.
%%%% ¡default!¤
'MultiplexBUT'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of the ¤binary undirected multiplex with fixed thresholds¤.
%%%% ¡default!¤
'In a binary undirected multiplex with fixed thresholds (BUT), the layers are those of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds. The supra-connectivity matrix has a number of partitions equal to the number of thresholds.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of the ¤binary undirected multiplex with fixed thresholds¤.¤

¤%%% ¡prop!
ID (data, string) is a few-letter code of the ¤binary undirected multiplex with fixed thresholds¤.
%%%% ¡default!¤
'MultiplexBUT ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of the ¤binary undirected multiplex with fixed thresholds¤.
%%%% ¡default!¤
'MultiplexBUT label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about the ¤binary undirected multiplex with fixed thresholds¤.
%%%% ¡default!¤
'MultiplexBUT notes'
	
¤%%% ¡prop!
GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.MULTIPLEX__.
%%%% ¡default!
Graph.MULTIPLEX
	
¤%%% ¡prop!
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type¤ __Graph.BINARY__  * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.BINARY * ones(layernumber); 

¤%%% ¡prop!
DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type¤ __Graph.UNDIRECTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.UNDIRECTED * ones(layernumber);
	
¤%%% ¡prop!
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.SELFCONNECTED * ones(layernumber);
value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                
	
%%% ¡prop!
NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.NONNEGATIVE * ones(layernumber);¤
	
¤%%% ¡prop!
A (result, cell) is the cell containing¤ multiplex binary adjacency matrices of the binary undirected multiplex.
	
¤%%%% ¡calculate!¤
A_WU = calculateValue@MultiplexWU(g, prop);¥\circled{1}\circlednote{1}{ calculates the graph MultiplexWU calling its parent \code{MultiplexWU}.}¥
	
thresholds = g.get('THRESHOLDS'); ¥\circled{2}\circlednote{2}{ gets the thresholds to be applied to \code{A\_WU}.}¥
L = length(A_WU); % number of layers ¥\circled{3}\circlednote{3}{ gets the number of layers in graph \code{A\_WU}.}¥
A = cell(length(thresholds) * L); ¥\circled{4}\circlednote{4}{ The new \code{MultiplexBUT} graph will have \code{L} layers for each threshold applied.}¥
	
if L > 0 && ~isempty(cell2mat(A_WU))
	A(:, :) = {eye(length(A_WU{1, 1}))};
	for i = 1:1:length(thresholds) ¥\circled{5}\circlednote{5}{ iterates over all the thresholds to be applied.}¥
		threshold = thresholds(i);
		layer = 1;
		for j = (i - 1) * L + 1:1:i * L ¥\circled{6}\circlednote{6}{ iterates over all the layers in \code{A\_WU}.}¥
			A{j, j} = dediagonalize(binarize(A_WU{layer, layer}, 'threshold', threshold)); ¥\circled{7}\circlednote{7}{ binarizes the present layer of the \code{A\_WU} graph according to the present threshold.}¥
			layer = layer + 1;
		end
	end
end
¤if g.get('RANDOMIZE')
	A = g.get('RANDOMIZATION', A);
end
value = A;¤

¤%%%% ¡gui! ¥\circled{8}\circlednote{8}{ Same as in note \circled{2} of \Coderef{cd:m:GraphBD:prop_update}.}¥
pr = PanelPropCell('EL', g, 'PROP', MultiplexBUT.A, ...
	'TABLE_HEIGHT', s(40), ...
	'XYSLIDERLOCK', true, ... 
	'XSLIDERSHOW', false, ...
	'YSLIDERSHOW', true, ...
	'YSLIDERLABELS', g.getCallback('ALAYERLABELS'), ...
	'YSLIDERWIDTH', s(5), ...
	'ROWNAME', g.getCallback('ANODELABELS'), ...
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});¤
	
¤%%% ¡prop!
PARTITIONS (result, rvector) returns the number of layers in the partitions of the graph.¤
%%%% ¡calculate!
l = g.get('LAYERNUMBER');
thresholds = g.get('THRESHOLDS');
value = ones(1, length(thresholds)) * l / length(thresholds);
	
¤%%% ¡prop!
ALAYERLABELS (query, stringlist) returns the layer labels to be used by the slider.
%%%% ¡calculate!
alayerlabels = g.get('LAYERLABELS');¤
if ~isa(g.getr('A'), 'NoValue') && length(alayerlabels) ~= g.get('LAYERNUMBER') % ensures that it's not unecessarily calculated
	thresholds = cellfun(@num2str, num2cell(g.get('THRESHOLDS')), 'uniformoutput', false);

	if length(alayerlabels) == length(g.get('B'))
		blayerlabels = alayerlabels;
	else % includes isempty(layerlabels)
		blayerlabels = cellfun(@num2str, num2cell([1:1:length(g.get('B'))]), 'uniformoutput', false);
	end
	
	alayerlabels = {};
	for i = 1:1:length(thresholds)¥\circled{9}\circlednote{9}{ sets the labels of the layers considering the thresholds and the number of layers in each multiplex graph for each threshold}¥
		for j = 1:1:length(blayerlabels)
			alayerlabels = [alayerlabels, [blayerlabels{j} '|' thresholds{i}]];
		end
	end
end
value = alayerlabels;

¤%%% ¡prop! 
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures('MultiplexBUT')

%%% ¡prop!
ATTEMPTSPEREDGE (parameter, scalar) is the attempts to rewire each edge.
%%%% ¡default!
5¤

¤%%% ¡prop!
RANDOMIZATION (query, cell) is the attempts to rewire each edge.
%%%% ¡calculate!
rng(g.get('RANDOM_SEED'), 'twister')

if isempty(varargin)
	value = {};
	return
end

A = varargin{1};
attempts_per_edge = g.get('ATTEMPTSPEREDGE');

for i = 1:length(A)
	tmp_a = A{i,i};

	¤random_g = GraphBU();¤  ¥\circled{10}\circlednote{10}{ Same as in  \Coderef{cd:m:MultilayerWD:prop_update} but using \code{GraphBU}.}¥
	random_g.set('ATTEMPTSPEREDGE', g.get('ATTEMPTSPEREDGE'));
	random_A = random_g.get('RANDOMIZATION', {tmp_a});
	A{i, i} = random_A;
end
value = A;¤

\end{lstlisting}

\begin{lstlisting}[
label=cd:m:MultiplexBUT:props,
caption={
	{\bf MultiplexBUT element props.}
	The \code{props} section of the generator code in \fn{\_MultiplexBUT.gen.m} defines the properties to be used in \code{MultiplexBUT}.
	\expand{cd:m:GraphBD:props}
}
]
%% ¡props!
	
%%% ¡prop!
THRESHOLDS (parameter, rvector) is the vector of thresholds.
%%%% ¡gui! ¥\circled{1}\circlednote{1}{ \code{PanelPropRVectorSmart} plots the panel for a row vector with an edit field. Smart means that (almost) any MatLab expression leading to a correct row vector can be introduced in the edit field. Also, the value of the vector can be limited between some MIN and MAX.}¥
pr = PanelPropRVectorSmart('EL', g, 'PROP', MultiplexBUT.THRESHOLDS, ...
	'MAX', 1, ...
	'MIN', -1, ...
	varargin{:});
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultiplexBUT:tests,
	caption={
		{\bf MultiplexBUT element tests.}
		The \code{tests} section from the element generator \fn{\_MultiplexBUT.gen.m}.
		\expand{cd:m:GraphBD:tests}
	}
]
%% ¡tests!

%%% ¡test!
%%%% ¡name!
Constructor - Full
%%%% ¡probability!
.01
%%%% ¡code!
B1 = [
	0 .1 .2 .3 .4 
	.1 0 .1 .2 .3
	.2 .1 0 .1 .2
	.3 .2 .1 0 .1
	.4 .3 .2 .1 0
	]; 
B = {B1, B1, B1}; ¥\circled{1}\circlednote{1}{ creates an example of the necessary input adjacency matrices.}¥
thresholds = [0 .1 .2 .3 .4]; ¥\circled{2}\circlednote{2}{ defines the thresholds.}¥
g = MultiplexBUT('B', B, 'THRESHOLDS', thresholds);
	
g.get('A_CHECK')
	
A = g.get('A');
for i = 1:1:length(B) * length(thresholds)
	for j = 1:1:length(B) * length(thresholds)
		if i == j
			threshold = thresholds(floor((i - 1) / length(B)) + 1);
			assert(isequal(A{i, i}, binarize(B1, 'threshold', threshold)), ...
			[BRAPH2.STR ':MultiplexBUT:' BRAPH2.FAIL_TEST], ...
			'MultiplexBUT is not constructing well.')
		else
			assert(isequal(A{i, j}, eye(length(B1))), ...
			[BRAPH2.STR ':MultiplexBUT:' BRAPH2.FAIL_TEST], ...
			'MultiplexBUT is not constructing well.')            
		end
	end
end

¤%%% ¡test!
%%%% ¡name!
Randomize Rules
%%%% ¡probability!
.01
%%%% ¡code!
B11 = randn(10);

B12 = rand(size(B11,1),size(B11,2));

B= {B11 B12 B12;
	B12 B11 B12;
	B12 B12 B11};
thresholds = [0 .5 1];¤
g = MultilayerBUT('B', B, 'THRESHOLDS', thresholds); 

¤g.set('RANDOMIZE', true);
g.set('ATTEMPTSPEREDGE', 4);
g.get('A_CHECK')

A = g.get('A');¤

¤assert(isequal(size(A{1}), size(B{1})), ...
[BRAPH2.STR ¤ ':MultilayerBUT:' ¤ BRAPH2.FAIL_TEST], ... ¤ 'MultilayerBUT Randomize is not functioning well.')¤

¤g2 = MultilayerBUT('B', B, 'THRESHOLDS', thresholds); 
¤g2.set('RANDOMIZE', false);
g2.set('ATTEMPTSPEREDGE', 4);
A2 = g2.get('A');
random_A = g2.get('RANDOMIZATION', A2);

for i = 1:length(A2)¤
	¤ if all(A2{i, i}==0, "all") %if all edges are zero, the new random matrix is all zeros
		assert(isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':MultilayerBUT:' BRAPH2.FAIL_TEST], ...
		'MultilayerBUT Randomize is not functioning well.')
	elseif isequal((length(A2{i, i}).^2)- length(A2{i, i}), sum(A2{i, i}==1, "all")) %if all nodes (except diagonal) are one, the random matrix is the same as original
		assert(isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':MultilayerBUT:' BRAPH2.FAIL_TEST], ...
		'MultilayerBUT Randomize is not functioning well.')
	else
		assert(~isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':MultilayerBUT:' BRAPH2.FAIL_TEST], ...
		'MultilayerBUT Randomize is not functioning well.')
	end

assert(isequal(numel(find(A2{i, i})), numel(find(random_A{i, i}))), ... % check same number of nodes
[BRAPH2.STR ':MultilayerBUT:' BRAPH2.FAIL_TEST], ...
'MultilayerBUT Randomize is not functioning well.')¤

assert(issymmetric(random_A{i, i}), ... % check symmetry ¥\circled{3}\circlednote{3}{ checks symmetry of each layer in the new random graph \code{random\_A} since they are undirected.}¥
[BRAPH2.STR ':MultilayerBUT:' BRAPH2.FAIL_TEST], ...
'MultilayerBUT Randomize is not functioning well.')

end

\end{lstlisting}

\clearpage

\subsection{Binary undirected ordinal multiplex graph with fixed thresholds (\code{OrdMxBUT})}

Finally, you will implement the \code{OrdMxBUT} graph based on the previous codes \code{GraphBD}, \code{MultilayerWD} and \code{MultiplexBUT}.
{%TEX 
Again the differences will be highlighted.
}%TEX 
An ordered multiplex is a type of multiplex graph that consists of a sequence of layers with edges between corresponding nodes in subsequent layers.

\begin{lstlisting}[
	label=cd:m:OrdMxBUT:header,
	caption={
		{\bf OrdMxBUT element header.}
		The \code{header} section of the generator code in \fn{\_OrdMxBUT.gen.m} provides the general information about the \code{OrdMxBUT} element.
		\expand{cd:m:GraphBD:header}
	}
]
¤%% ¡header!¤
OrdMxBUT < OrdMxWU (g, ordinal multiplex binary undirected with fixed thresholds) is a binary undirected ordinal multiplex with fixed thresholds. ¥\circled{1}\circlednote{1}{ \code{OrdMxBUT} is a child of \code{OrdMxWU}, which in turn derives from \code{Graph}.}¥
	
¤%%% ¡description!¤
In a binary undirected ordinal multiplex with fixed thresholds (BUT), all the layers consist of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds. The supra-connectivity matrix has a number of partitions equal to the number of thresholds. The layers are connected in an ordinal fashion, i.e., only consecutive layers are connected.

¤%%% ¡build!¤
1
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:OrdMxBUT:prop_update,
	caption={
		{\bf OrdMxBUT element prop update.}
		The \code{props\_update} section of the generator code in \fn{\_OrdMxBUT.gen.m} updates the properties of \code{OrdMxBUT}.
		\expand{cd:m:MultiplexBUT:prop_update}
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of the ¤binary undirected ordinal multiplex with fixed thresholds.s¤.
%%%% ¡default!¤
'OrdMxBUT'
	
¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of the ¤binary undirected ordinal multiplex with fixed thresholds.¤.
%%%% ¡default!¤
'In a binary undirected ordinal multiplex with fixed thresholds (BUT), all the layers consist of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds. The supra-connectivity matrix has a number of partitions equal to the number of thresholds. The layers are connectedin an ordinal fashion, i.e., only consecutive layers are connected.'
	
¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of the ¤binary undirected ordinal multiplex with fixed thresholds¤.¤
	
¤%%% ¡prop!
ID (data, string) is a few-letter code of the ¤binary undirected ordinal multiplex with fixed thresholds¤.
%%%% ¡default!¤
'OrdMxBUT ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of the ¤binary undirected ordinal multiplex with fixed thresholds¤.
%%%% ¡default!¤
'OrdMxBUT label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about the ¤binary undirected ordinal multiplex with fixed thresholds¤.
%%%% ¡default!¤
'OrdMxBUT notes'

¤%%% ¡prop!
GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.ORDERED_MULTIPLEX__.
%%%% ¡default!
Graph.ORDERED_MULTIPLEX

¤%%% ¡prop!
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type __Graph.BINARY__  * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.BINARY * ones(layernumber); ¤
	
¤%%% ¡prop!
DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type __Graph.UNDIRECTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.UNDIRECTED * ones(layernumber);¤
	
¤%%% ¡prop!
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.SELFCONNECTED * ones(layernumber);
value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                
	
%%% ¡prop!
NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.NONNEGATIVE * ones(layernumber);¤
	
¤%%% ¡prop!
A (result, cell) is the cell containing¤binary supra-adjacency matrix of the binary undirected multiplex with fixed thresholds (BUT).
	
¤%%%% ¡calculate!¤
A_WU = calculateValue@OrdMxWU(g, prop);¥\circled{1}\circlednote{1}{ calculates the graph OrdMxWU calling the parent \code{OrdMxWU}.}¥
	
¤thresholds = g.get('THRESHOLDS');  ¥\circled{2}\circlednote{2}{ Same as in notes  \circled{2}, \circled{3}, and \circled{4} of \Coderef{cd:m:MultiplexBUT:prop_update}..}¥
L = length(A_WU); % number of layers 
A = cell(length(thresholds)*L);¤
	
if L > 0 && ~isempty(cell2mat(A_WU))
	A(:, :) = {zeros(length(A_WU{1, 1}))};
	for i = 1:1:length(thresholds) ¥\circled{3}\circlednote{3}{ constructs an ordinal muliplex binary undirected graph for each threshold.}¥
		threshold = thresholds(i);
		layer = 1;
		for j = (i - 1) * L + 1:1:i * L ¥\circled{4}\circlednote{4}{ loops over the layers of \code{A\_Wu} for each threshold.}¥
			for k = (i - 1) * L + 1:1:i * L
				if j == k ¥\circled{5}\circlednote{5}{ sets the layers constructed by binarizing \code{A\_Wu} according to the present threshold on the diagonal of the supra-adjacency matrix.}¥
					A{j, j} = dediagonalize(binarize(A_WU{layer, layer}, 'threshold', threshold));
				elseif (j-k)==1 || (k-j)==1 ¥\circled{6}\circlednote{6}{ connects consecutive layers.}¥
					A(j, k) = {eye(length(A{1, 1}))};
				else ¥\circled{7}\circlednote{7}{ does NOT connect NON-consecutive layers.}¥
					A(j, k) = {zeros(length(A{1, 1}))};
				end
			end
			layer = layer + 1;
		end
	end
end
¤if g.get('RANDOMIZE')
	A = g.get('RANDOMIZATION', A);
end
value = A;¤
	
¤%%%% ¡gui!
pr = PanelPropCell('EL', g, 'PROP', OrdMxBUT.A, ...
	'TABLE_HEIGHT', s(40), ...
	'XYSLIDERLOCK', true, ... 
	'XSLIDERSHOW', false, ...
	'YSLIDERSHOW', true, ...
	'YSLIDERLABELS', g.getCallback('ALAYERLABELS'), ...
	'YSLIDERWIDTH', s(5), ...
	'ROWNAME', g.getCallback('ANODELABELS'), ...
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});¤
	
¤%%% ¡prop!
PARTITIONS (result, rvector) returns the number of layers in the partitions of the graph.
%%%% ¡calculate!
l = g.get('LAYERNUMBER');
thresholds = g.get('THRESHOLDS');
value = ones(1, length(thresholds)) * l / length(thresholds);¤
	
¤%%% ¡prop!
ALAYERLABELS (query, stringlist) returns the layer labels to be used by the slider.
%%%% ¡calculate!
alayerlabels = g.get('LAYERLABELS');
if ~isa(g.getr('A'), 'NoValue') && length(alayerlabels) ~= g.get('LAYERNUMBER') % ensures that it's not unecessarily calculated
	thresholds = cellfun(@num2str, num2cell(g.get('THRESHOLDS')), 'uniformoutput', false);

	if length(alayerlabels) == length(g.get('B'))
		blayerlabels = alayerlabels;
	else % includes isempty(layerlabels)
		blayerlabels = cellfun(@num2str, num2cell([1:1:length(g.get('B'))]), 'uniformoutput', false);
	end
		
	alayerlabels = {};
	for i = 1:1:length(thresholds)
		for j = 1:1:length(blayerlabels)
			alayerlabels = [alayerlabels, [blayerlabels{j} '|' thresholds{i}]];
		end
	end
end
value = alayerlabels;¤
	
¤%%% ¡prop!
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures¤('OrdMxBUT')

¤%%% ¡prop!
ATTEMPTSPEREDGE (parameter, scalar) is the attempts to rewire each edge.
%%%% ¡default!
5

%%% ¡prop!
RANDOMIZATION (query, cell) is the attempts to rewire each edge. ¥\circled{8}\circlednote{8}{ same as in \Coderef{cd:m:MultiplexBUT:prop_update}.}¥
%%%% ¡calculate!
rng(g.get('RANDOM_SEED'), 'twister')

if isempty(varargin)
	value = {};
	return
end

A = varargin{1};
attempts_per_edge = g.get('ATTEMPTSPEREDGE');

for i = 1:length(A)
	tmp_a = A{i,i};

	random_g = GraphBU();
	random_g.set('ATTEMPTSPEREDGE', g.get('ATTEMPTSPEREDGE'));
	random_A = random_g.get('RANDOMIZATION', {tmp_a});
	A{i, i} = random_A;
end
value = A;¤

\end{lstlisting}



\begin{lstlisting}[
	label=cd:m:OrdMxBUT:props,
	caption={
	{\bf OrdMxBUT element props.}
	The \code{props} section of generator code for \fn{\_OrdMxBUT.gen.m} defines the properties to be used in \code{MultiplexBUT}.
	\expand{cd:m:MultiplexBUT:props}
	}
]
¤%% ¡props!

%%% ¡prop!
THRESHOLDS (parameter, rvector) is the vector of thresholds.
%%%% ¡gui!
pr = PanelPropRVectorSmart('EL', g, 'PROP', ¤OrdMxBUT.THRESHOLDS, ¤ ...
	'MAX', 1, ...
	'MIN', -1, ...
	varargin{:});¤
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:OrdMxBUT:tests,
	caption={
		{\bf OrdMxBUT element tests.}
		The \code{tests} section from the element generator \fn{\_OrdMxBUT.gen.m}.
		\expand{cd:m:MultiplexBUT:tests}
	}
]
%% ¡tests!

%%% ¡excluded_props!
[OrdMxBUT.PFGA OrdMxBUT.PFGH]

¤%%% ¡test!
%%%% ¡name!
Constructor - Full
%%%% ¡probability!
.01
%%%% ¡code!
B1 = [
	0 .1 .2 .3 .4 
	.1 0 .1 .2 .3
	.2 .1 0 .1 .2
	.3 .2 .1 0 .1
	.4 .3 .2 .1 0
	];
B = {B1, B1, B1};
thresholds = [0 .1 .2 .3 .4];¤
g = OrdMxBUT('B', B, 'THRESHOLDS', thresholds);
	
¤g.get('A_CHECK')
	
A = g.get('A');¤
for i = 1:1:length(thresholds)
	threshold = thresholds(i);
	for j = (i - 1) * length(B) + 1:1:i * length(B)
		for k = (i - 1) * length(B) + 1:1:i * length(B)
			if j == k
				assert(isequal(A{j, j}, binarize(B1, 'threshold', threshold)), ...
					[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
					'OrdMxBUT is not constructing well.')
			elseif (j-k)==1 || (k-j)==1
				assert(isequal(A{j, k}, eye(length(B1))), ...
					[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
					'OrdMxBUT is not constructing well.')
			else 
				assert(isequal(A{j, k}, zeros(length(B1))), ...
					[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
					'OrdMxBUT is not constructing well.')
			end
		end
	end
end

¤%%% ¡test!
%%%% ¡name!
Randomize Rules  ¥\circled{1}\circlednote{1}{ same as in \Coderef{cd:m:MultiplexBUT:tests}.}¥
%%%% ¡probability!
.01
%%%% ¡code!
B1 = randn(10);
B = {B1, B1, B1};
thresholds = [0 .1 .2 .3 .4];
g = OrdMxBUT('B', B, 'THRESHOLDS', thresholds);

g.set('RANDOMIZE', true);
g.set('ATTEMPTSPEREDGE', 4);
g.get('A_CHECK')

A = g.get('A');

assert(isequal(size(A{1}), size(B{1})), ...
[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
'OrdMxBUT Randomize is not functioning well.')

g2 = OrdMxBUT('B', B, 'THRESHOLDS', thresholds);
g2.set('RANDOMIZE', false);
g2.set('ATTEMPTSPEREDGE', 4);
A2 = g2.get('A');
random_A = g2.get('RANDOMIZATION', A2);

for i = 1:length(A2)
	if all(A2{i, i}==0, "all") %if all edges are zero, the new random matrix is all zeros
		assert(isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
		'OrdMxBUT Randomize is not functioning well.')
		elseif isequal((length(A2{i, i}).^2)- length(A2{i, i}), sum(A2{i, i}==1, "all")) %if all nodes (except diagonal) are one, the random matrix is the same as original
		assert(isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
		'OrdMxBUT Randomize is not functioning well.')
	else
		assert(~isequal(A2{i, i}, random_A{i, i}), ...
		[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
		'OrdMxBUT Randomize is not functioning well.')
	end

assert(isequal(numel(find(A2{i, i})), numel(find(random_A{i, i}))), ... % check same number of nodes
[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
'OrdMxBUT Randomize is not functioning well.')

assert(issymmetric(random_A{i, i}), ... % check symmetry 
[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
'OrdMxBUT Randomize is not functioning well.')

end¤

\end{lstlisting}

%\bibliography{biblio}
%\bibliographystyle{plainnat}

\end{document}